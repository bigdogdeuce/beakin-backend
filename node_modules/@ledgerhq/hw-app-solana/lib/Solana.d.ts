/// <reference types="node" />
/// <reference types="node" />
import Transport from "@ledgerhq/hw-transport";
import { DescriptorInput } from "./descriptor";
/**
 * Solana API
 *
 * @param transport a transport for sending commands to a device
 * @param scrambleKey a scramble key
 *
 * @example
 * import Solana from "@ledgerhq/hw-app-solana";
 * const solana = new Solana(transport);
 */
export default class Solana {
    private transport;
    constructor(transport: Transport, scrambleKey?: string);
    /**
     * Get Solana address (public key) for a BIP32 path.
     *
     * Because Solana uses Ed25519 keypairs, as per SLIP-0010
     * all derivation-path indexes will be promoted to hardened indexes.
     *
     * @param path a BIP32 path
     * @param display flag to show display
     * @returns an object with the address field
     *
     * @example
     * solana.getAddress("44'/501'/0'").then(r => r.address)
     */
    getAddress(path: string, display?: boolean): Promise<{
        address: Buffer;
    }>;
    /**
     * Provides trusted dynamic and signed coin metadata
     *
     * @param data An object containing the descriptor and its signature from the CAL
     */
    provideTrustedDynamicDescriptor(data: DescriptorInput): Promise<boolean>;
    /**
     * Sign a Solana transaction.
     *
     * @param path a BIP32 path
     * @param txBuffer serialized transaction
     * @param userInputType optional user input type (ata or sol, for the case of token transfers)
     *
     * @returns an object with the signature field
     *
     * @example
     * solana.signTransaction("44'/501'/0'", txBuffer).then(r => r.signature)
     */
    signTransaction(path: string, txBuffer: Buffer, userInputType?: "ata" | "sol"): Promise<{
        signature: Buffer;
    }>;
    /**
     * Sign a Solana off-chain message.
     *
     * @param path a BIP32 path
     * @param msgBuffer serialized off-chain message
     *
     * @returns an object with the signature field
     *
     * @example
     * solana.signOffchainMessage("44'/501'/0'", msgBuffer).then(r => r.signature)
     */
    signOffchainMessage(path: string, msgBuffer: Buffer): Promise<{
        signature: Buffer;
    }>;
    /**
     * Get application configuration.
     *
     * @returns application config object
     *
     * @example
     * solana.getAppConfiguration().then(r => r.version)
     */
    getAppConfiguration(): Promise<AppConfig>;
    /**
     * Method returning a 4 bytes TLV challenge as an hex string
     *
     * @returns {Promise<string>}
     */
    getChallenge(): Promise<string>;
    /**
     * Provides a trusted name to be displayed during transactions in place of the token address it is associated to. It shall be run just before a transaction involving the associated address that would be displayed on the device.
     *
     * @param data a stringified buffer of some TLV encoded data to represent the trusted name
     * @returns a boolean
     */
    provideTrustedName(data: string): Promise<boolean>;
    private pathToBuffer;
    private serializePath;
    private sendToDevice;
    private throwOnFailure;
}
declare enum PubKeyDisplayMode {
    LONG = 0,
    SHORT = 1
}
type AppConfig = {
    blindSigningEnabled: boolean;
    pubKeyDisplayMode: PubKeyDisplayMode;
    version: string;
};
export {};
//# sourceMappingURL=Solana.d.ts.map